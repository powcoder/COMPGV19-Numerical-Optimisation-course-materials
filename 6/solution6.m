%% *COMPGV19: Tutorial 6*
%
% Marta Betcke and Kiko RulÂ·lan
% 

%%
% *Exercise 3*
% Minimise the surface given by the boundary conditions using Algorithm 7.1
close all;
clear all;
tic;
%==============================
% Parameters
%==============================
maxIter = 1000;
tol = 1e-4;

%==============================
% Initialisation
%==============================
% Dimensions
q = 14 % dimension of interior square
n = q+2; % dimension of square with boundary
s = linspace(0,1-1/n,n-1);
% Boundary 1
leftBoundary   = sin(pi*s+pi);   % left boundary  
rightBoundary  = sin(3*pi*s+pi); % right boundary 
topBoundary    = sin(3*pi*s);    % top boundary   
bottomBoundary = sin(pi*s);      % bottom boundary
% % Boundary 2
% leftBoundary   = 2*s;                  % left boundary  
% topBoundary    = exp(-6*s)+1;          % right boundary 
% rightBoundary  = 1+exp(6*s)/exp(6);    % top boundary    
% bottomBoundary = 2-2*s;                % bottom boundary

bndFun = [leftBoundary topBoundary rightBoundary bottomBoundary];
figure, plot(bndFun);
% Indicies of the boundary nodes in counter clockwise order
bndInd = [1:q+2, (1:q)*(q+2) + ones(1,q)*(q+2), (q+1)*(q+2) + (q+2:-1:1), (q:-1:1)*(q+2) + ones(1,q)];
boundaryM = zeros(q+2,q+2);
boundaryM(bndInd(:)) = bndFun;
% Initialise surface to zero
x0 = zeros(q*q, 1);

%==============================
% Assign function handlers
%==============================
delta = 1e-2; % for computing numerical gradient
F.f = @(x) surfaceFunc_vector(x, boundaryM, q);
F.df = @(x) surfaceGrad(x, boundaryM, q, delta);
F.d2f = @(x) surfaceHess(x, boundaryM, q, delta);

%==============================
% Newton line search
%==============================
alpha0 = 1;
lsOpts_LS.c1 = 1e-4;
lsOpts_LS.c2 = 0.9;
lsFun = @(x_k, p_k, alpha0) lineSearch(F, x_k, p_k, alpha0, lsOpts_LS);
start_time = clock;
[xLS_NewtonCG, fLS_NewtonCG, nIterLS_NewtonCG, infoLS_NewtonCG] = descentLineSearch(F, 'newton-cg', lsFun, alpha0, x0, tol, maxIter);
end_time = clock;
% Measure computational time
disp(['Computational time for Newton-CG: ' num2str(etime(end_time, start_time))]);
disp(strcat('Num iter Newton-CG: ', num2str(nIterLS_NewtonCG)));

%==============================
% BFGS
%==============================
% Line search parameters
alpha0 = 1;
% Strong Wolfe LS
lsOpts_LS.c1 = 1e-4;
lsOpts_LS.c2 = 0.5; % 0.1 Good for Newton, 0.9 - good for steepest descent, 0.5 compromise.
lsFunS = @(x_k, p_k, alpha0) lineSearch(F, x_k, p_k, alpha0, lsOpts_LS);
lsFun = lsFunS;
start_time = clock;
[xLS_BFGS, fLS_BFGS, nIterLS_BFGS, infoLS_BFGS] = descentLineSearch(F, 'bfgs', lsFun, alpha0, x0, tol, maxIter);
end_time = clock;
% Measure computational time
disp(['Computational time for BFGS: ' num2str(etime(end_time, start_time))]);
disp(strcat('Num iter BFGS: ', num2str(nIterLS_BFGS)));


%==============================
% Trust region - SR1
%==============================
% Trust region parameters 
eta = 0.1;  % Step acceptance relative progress threshold
Delta = 1; % Trust region radius
% Minimisation with SR-1 trust region method
Fsr1 = rmfield(F,'d2f');
start_time = clock;
[xTR_SR1, fTR_SR1, nIterTR_SR1, infoTR_SR1] = trustRegionLS(Fsr1, x0, @solverCM2dSubspaceExtLS, Delta, eta, tol, maxIter, 0, 1);
end_time = clock;
% Measure computational time
disp(['Computational time for TR-SR1: ' num2str(etime(end_time, start_time))]);
disp(strcat('Num iter TR-SR1: ', num2str(nIterTR_SR1)));


%==============================
% Visualize convergence
%==============================
X = 0:1/(q+1):1;
Y = 0:1/(q+1):1;
visualizeSurface(infoLS_NewtonCG, X, Y, boundaryM, 'final');
visualizeSurface(infoLS_BFGS, X, Y, boundaryM, 'final');
visualizeSurface(infoTR_SR1, X, Y, boundaryM, 'final');

%==============================
% Summary for different dimensions - Generated by running the script with different q values
%==============================
qVec = [9 10 11 12 13 14 15 16 17 18 19];
nVar = qVec.*qVec;
nIter_NCG  = [8  8 10  8  9   11 8   13  11  11  9];
nIter_BFGS = [41 44 58 61 61  71 71  73  76  79  84];
nIter_SR1  = [54 59 87 94 102 94 108 112 142 135 125];

time_NCG  = [1.93 2.71  5.14  5.89  9.01  16.84 16.23 35.11 72.95  104.01 118.78];
time_BFGS = [0.72 0.70  1.10  1.45  1.45  2.19  2.44  2.97  3.78   6.75   10.03];
time_SR1  = [7.77 11.13 28.98 42.36 46.04 42.13 58.17 61.86 103.56 102.29 91.54];

% Number of iterations
figure;
semilogy(nVar, nIter_NCG,  'Color', 'r', 'LineWidth', 2);
hold on;
semilogy(nVar, nIter_BFGS, 'Color', 'g', 'LineWidth', 2);
semilogy(nVar, nIter_SR1,  'Color', 'b', 'LineWidth', 2);
xlabel('number of variables');
ylabel('number of iterations');
legend('LS-Newton-CG', 'LS-BFGS', 'TR-SR1');
grid on;

% Computational time
figure;
semilogy(nVar, time_NCG,  'Color', 'r', 'LineWidth', 2);
hold on;      
semilogy(nVar, time_BFGS, 'Color', 'g', 'LineWidth', 2);
semilogy(nVar, time_SR1,  'Color', 'b', 'LineWidth', 2);
xlabel('number of variables');
ylabel('computational time [s]');
legend('LS-Newton-CG', 'LS-BFGS', 'TR-SR1');
grid on;

%%
%==============================
%  Subfunctions
%==============================
%%

%% descentLineSearch.m
% Wrapper function executing iteration with descent direction and line search method
%
% <include>descentLineSearch.m</include>
%%

%% surfaceFunc_vector.m
% Function to minimise the surface area. Input in Vector form
%
% <include>surfaceFunc_vector.m</include>

%% surfaceFunc_matrix.m
% Function to minimise the surface area. Input in matrix form
%
% <include>surfaceFunc_matrix.m</include>

%% surfaceGrad.m
% Gradient handler of the function to minimise the surface area
%
% <include>surfaceGrad.m</include>

%% surfaceHess.m
% Hessian handler of the function to minimise the surface area
%
% <include>surfaceHess.m</include>

%% visualizeSurface.m
% Convergence plot of iterates
%
% <include>visualizeSurface.m</include>


